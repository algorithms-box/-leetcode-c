以下是十大常见排序算法的时间复杂度和空间复杂度的表格概述：

| 排序算法   | 最好情况          | 平均情况          | 最坏情况          | 空间复杂度       | 稳定性  |
|------------|------------------|------------------|------------------|----------------|---------|
| 冒泡排序   | O(n)             | O(n^2)           | O(n^2)           | O(1)           | 稳定    |
| 选择排序   | O(n^2)           | O(n^2)           | O(n^2)           | O(1)           | 不稳定  |
| 插入排序   | O(n)             | O(n^2)           | O(n^2)           | O(1)           | 稳定    |
| 希尔排序   | O(n)             | O(n^1.3)         | O(n^2)           | O(1)           | 不稳定  |
| 归并排序   | O(n log n)       | O(n log n)       | O(n log n)       | O(n)           | 稳定    |
| 快速排序   | O(n log n)       | O(n log n)       | O(n^2)           | O(log n)       | 不稳定  |
| 堆排序     | O(n log n)       | O(n log n)       | O(n log n)       | O(1)           | 不稳定  |
| 计数排序   | O(n + k)         | O(n + k)         | O(n + k)         | O(k)           | 稳定    |
| 桶排序     | O(n + k)         | O(n + k)         | O(n^2)           | O(k)           | 稳定    |
| 基数排序   | O(nk)            | O(nk)            | O(nk)            | O(n + k)       | 稳定    |

说明：

- n：数组中的元素数量。
- k：数组中元素的最大值（计数排序和基数排序）或桶的数量（桶排序）。
- 稳定性指的是排序算法是否会保持相等元素的相对顺序不变。
- 空间复杂度中的O(1)表示排序过程中使用的额外空间不随输入数据的大小而变化，即常数空间。
- 空间复杂度中的O(n)表示排序过程中使用的额外空间与输入数据的大小成正比。
- 空间复杂度中的O(log n)通常与递归调用的深度相关，如快速排序。
- 计数排序、桶排序和基数排序的最好、平均、最坏情况时间复杂度取决于具体实现和数据分布。

请注意，实际性能可能会因实现细节、数据分布和硬件环境等因素而有所不同。此外，快速排序的平均性能通常非常好，尽管其最坏情况是O(n^2)，但这种情况很少发生，除非输入数据是已经排序的。

当然，下面是十大排序算法的核心思路的详细描述：

1. **冒泡排序**：
   - 重复遍历待排序序列，每次遍历都将相邻元素中逆序的一对交换位置，直到整个序列有序。每一轮遍历都会将最大（或最小）的元素“冒泡”到序列的末端。

2. **选择排序**：
   - 遍历序列，找到最小（或最大）元素，将其与序列的第一个元素交换位置。然后在剩余的序列中重复这个过程，每次迭代都将范围缩小，直到整个序列有序。

3. **插入排序**：
   - 从序列的第二个元素开始，将每个元素插入到前面已经排序的子序列中的适当位置。这个过程就像在手中整理一副扑克牌，每次将一张牌插入到正确的位置。

4. **希尔排序**：
   - 先将整个序列按照不同的步长分割成多个子序列，对每个子序列进行直接插入排序，然后减小步长，重复这个过程，直到步长为1，此时整个序列几乎有序，再进行一次直接插入排序。

5. **归并排序**：
   - 将序列分成两半，对每一半递归地进行归并排序，然后将两个有序的子序列合并成一个最终的有序序列。合并过程是通过比较两个子序列的头部元素并将较小的元素放入新序列中来完成的。

6. **快速排序**：
   - 选择一个元素作为“基准”（pivot），将序列中的其他元素与基准进行比较，并将小于基准的元素放到基准的左边，将大于基准的元素放到基准的右边。这个过程称为“分区”。然后递归地对基准左右两边的子序列进行快速排序。

7. **堆排序**：
   - 利用堆数据结构（一种特殊的完全二叉树）进行排序。首先将序列构建成一个最大堆，然后将堆顶元素（最大值）与序列末尾元素交换，缩小堆的范围，然后重新调整堆，重复这个过程直到序列有序。

8. **计数排序**：
   - 非比较型排序算法，适用于一定范围内的整数。创建一个计数数组，用于统计每个整数值出现的次数，然后根据计数数组的值将元素放入最终的排序序列中。

9. **桶排序**：
   - 将序列分割成多个“桶”，每个桶负责排序序列中的一部分数据。每个桶内部可以采用其他排序算法进行排序，最后按顺序合并各个桶中的数据。

10. **基数排序**：
    - 按照数字的位数切割成不同的数字，然后按照每个位数分别比较。首先按照最低位排序，然后收集；再按照次低位排序，再收集，以此类推，直到最高位。

这些算法的核心思路体现了不同的排序策略和优化方法，适用于不同的数据集和应用场景。
